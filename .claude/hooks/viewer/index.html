<!DOCTYPE html>
<html lang="en" data-theme="system">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Hall Monitor</title>
  <link rel="icon" type="image/svg+xml" href="/logo.svg">

  <!-- Google Fonts: Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">

  <!-- Theme CSS -->
  <link rel="stylesheet" href="/styles/theme.css">

  <!-- Vue 3 from CDN -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
</head>
<body>
  <div id="app">
    <div class="app-container">
      <!-- Header -->
      <header class="header">
        <div class="header-brand">
          <img src="/logo.svg" alt="Logo" class="header-logo" />
          <h1>Claude Hall Monitor</h1>
        </div>
        <theme-toggle></theme-toggle>
      </header>

      <!-- Main Content -->
      <main>
        <tab-container
          v-model:active-tab="currentTab"
          :tabs="tabs"
        >
          <template #dashboard>
            <dashboard-view
              :data="dashboardData"
              :loading="dashboardLoading"
            ></dashboard-view>
          </template>

          <template #logs>
            <log-viewer
              :entries="entries"
              :sessions="sessions"
              :current-session="currentSession"
              v-model:selected-session="selectedSession"
            ></log-viewer>
          </template>

          <template #plans>
            <plan-tracker-view
              :plans="plans"
              :loading="plansLoading"
            ></plan-tracker-view>
          </template>
        </tab-container>
      </main>

      <!-- Footer -->
      <footer class="footer">
        <div class="connection-status">
          <span
            class="status-dot"
            :class="{ connected: isConnected }"
          ></span>
          <span>{{ connectionText }}</span>
          <span v-if="lastHeartbeat" class="heartbeat">
            ({{ formatHeartbeat }})
          </span>
        </div>
        <div class="entry-count">
          {{ entries.length }} total entries
        </div>
      </footer>
    </div>
  </div>

  <script>
    const { createApp, ref, computed, onMounted, onUnmounted, watch } = Vue;

    // ===== Vue App =====
    const app = createApp({
      setup() {
        // === State ===
        const entries = ref([]);
        const isConnected = ref(false);
        const lastHeartbeat = ref(null);
        const reconnectAttempts = ref(0);
        const currentTab = ref('dashboard');
        const sessions = ref([]);
        const currentSession = ref(null);
        const selectedSession = ref(null);

        // === SSE Connection ===
        let eventSource = null;
        let reconnectTimeout = null;

        const tabs = [
          { id: 'dashboard', label: 'Dashboard' },
          { id: 'logs', label: 'Hook Log' },
          { id: 'plans', label: 'Plans' },
        ];

        const connectionText = computed(() => {
          if (isConnected.value) {
            return 'Connected';
          }
          if (reconnectAttempts.value > 0) {
            return `Reconnecting (${reconnectAttempts.value})...`;
          }
          return 'Disconnected';
        });

        const formatHeartbeat = computed(() => {
          if (!lastHeartbeat.value) return '';
          try {
            const date = new Date(lastHeartbeat.value);
            return date.toLocaleTimeString('en-US', {
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false,
            });
          } catch {
            return '';
          }
        });

        // Dashboard state
        const dashboardData = ref(null);
        const dashboardLoading = ref(false);
        let dashboardPollInterval = null;

        // Plans state
        const plans = ref([]);
        const plansLoading = ref(false);
        let planEventSource = null;

        // Fetch dashboard data
        async function fetchDashboard() {
          try {
            dashboardLoading.value = dashboardData.value === null;
            const res = await fetch('/api/dashboard');
            if (res.ok) {
              dashboardData.value = await res.json();
            }
          } catch (err) {
            console.error('Failed to fetch dashboard:', err);
          } finally {
            dashboardLoading.value = false;
          }
        }

        async function fetchSessions() {
          try {
            const res = await fetch('/api/sessions');
            const data = await res.json();
            sessions.value = data.sessions;
            currentSession.value = data.current_session;
            if (!selectedSession.value && data.current_session) {
              selectedSession.value = data.current_session;
            } else if (!selectedSession.value && data.sessions.length > 0) {
              selectedSession.value = data.sessions[0].session_id;
            }
          } catch (err) {
            console.error('Failed to fetch sessions:', err);
          }
        }

        // Fetch plans data
        async function fetchPlans() {
          try {
            plansLoading.value = plans.value.length === 0;
            const res = await fetch('/api/plans');
            if (res.ok) {
              const data = await res.json();
              plans.value = data.plans;
            }
          } catch (err) {
            console.error('Failed to fetch plans:', err);
          } finally {
            plansLoading.value = false;
          }
        }

        // Connect to plan SSE
        function connectPlansSSE() {
          if (planEventSource) {
            planEventSource.close();
          }

          planEventSource = new EventSource('/events/plans');

          planEventSource.addEventListener('plans', (event) => {
            try {
              plans.value = JSON.parse(event.data);
            } catch (err) {
              console.error('Failed to parse plans:', err);
            }
          });

          planEventSource.addEventListener('plan_update', (event) => {
            try {
              const update = JSON.parse(event.data);
              const index = plans.value.findIndex(p => p.name === update.plan.name);
              if (index >= 0) {
                plans.value[index] = update.plan;
              } else {
                plans.value.unshift(update.plan);
              }
            } catch (err) {
              console.error('Failed to parse plan update:', err);
            }
          });

          planEventSource.onerror = () => {
            planEventSource.close();
            setTimeout(connectPlansSSE, 3000);
          };
        }

        function disconnectPlansSSE() {
          if (planEventSource) {
            planEventSource.close();
            planEventSource = null;
          }
        }

        function connect() {
          // Clean up existing connection
          if (eventSource) {
            eventSource.close();
          }

          const sessionParam = selectedSession.value ? `?session=${selectedSession.value}` : '';
          const url = `/events${sessionParam}`;
          eventSource = new EventSource(url);

          eventSource.onopen = () => {
            console.log('SSE connected');
            isConnected.value = true;
            reconnectAttempts.value = 0;
          };

          eventSource.onerror = (error) => {
            console.error('SSE error:', error);
            isConnected.value = false;
            eventSource.close();
            scheduleReconnect();
          };

          // Handle 'entries' event (initial load)
          eventSource.addEventListener('entries', (event) => {
            try {
              const data = JSON.parse(event.data);
              entries.value = Array.isArray(data) ? data : [];
              console.log(`Loaded ${entries.value.length} entries`);
            } catch (err) {
              console.error('Failed to parse entries:', err);
            }
          });

          // Handle 'entry' event (new entry)
          eventSource.addEventListener('entry', (event) => {
            try {
              const entry = JSON.parse(event.data);
              entries.value.push(entry);
            } catch (err) {
              console.error('Failed to parse entry:', err);
            }
          });

          // Handle 'heartbeat' event
          eventSource.addEventListener('heartbeat', (event) => {
            try {
              const data = JSON.parse(event.data);
              lastHeartbeat.value = data.timestamp;
            } catch (err) {
              // Ignore heartbeat parse errors
            }
          });

          // Handle 'error' event from server
          eventSource.addEventListener('error', (event) => {
            try {
              const data = JSON.parse(event.data);
              console.error('Server error:', data);
            } catch {
              // Ignore
            }
          });
        }

        function scheduleReconnect() {
          if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
          }

          // Exponential backoff: 1s, 2s, 4s, 8s, max 30s
          const delay = Math.min(
            1000 * Math.pow(2, reconnectAttempts.value),
            30000
          );

          reconnectAttempts.value++;
          console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts.value})`);

          reconnectTimeout = setTimeout(() => {
            connect();
          }, delay);
        }

        function disconnect() {
          if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
            reconnectTimeout = null;
          }
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          isConnected.value = false;
        }

        // === Watch selectedSession ===
        watch(selectedSession, (newSession, oldSession) => {
          if (newSession && newSession !== oldSession) {
            // Close existing connection
            if (eventSource) {
              eventSource.close();
              eventSource = null;
            }
            // Clear entries and reconnect
            entries.value = [];
            connect();
          }
        });

        // Start/stop dashboard polling and plans SSE based on active tab
        watch(currentTab, (newTab, oldTab) => {
          // Dashboard tab
          if (newTab === 'dashboard') {
            fetchDashboard();
            dashboardPollInterval = setInterval(fetchDashboard, 5000);
          } else if (oldTab === 'dashboard' && dashboardPollInterval) {
            clearInterval(dashboardPollInterval);
            dashboardPollInterval = null;
          }

          // Plans tab
          if (newTab === 'plans') {
            fetchPlans();
            connectPlansSSE();
          } else if (oldTab === 'plans') {
            disconnectPlansSSE();
          }
        });

        // === Lifecycle ===
        onMounted(() => {
          fetchSessions();
          connect();
          // Dashboard is the default tab, so start polling immediately
          fetchDashboard();
          dashboardPollInterval = setInterval(fetchDashboard, 5000);
        });

        onUnmounted(() => {
          disconnect();
          disconnectPlansSSE();
          if (dashboardPollInterval) {
            clearInterval(dashboardPollInterval);
            dashboardPollInterval = null;
          }
        });

        // === Return ===
        return {
          entries,
          isConnected,
          connectionText,
          lastHeartbeat,
          currentTab,
          tabs,
          formatHeartbeat,
          sessions,
          currentSession,
          selectedSession,
          fetchSessions,
          dashboardData,
          dashboardLoading,
          plans,
          plansLoading,
        };
      },
    });

    // ===== Component Registration =====

    // ===== EventBadge Component =====
    app.component('event-badge', {
      props: {
        event: {
          type: String,
          required: true,
        },
      },
      template: `
        <span class="event-badge" :class="badgeClass">
          {{ event }}
        </span>
      `,
      computed: {
        badgeClass() {
          return 'badge-' + this.event;
        },
      },
    });

    // ===== ThemeToggle Component =====
    app.component('theme-toggle', {
      template: `
        <button class="theme-toggle" @click="cycle" :title="'Theme: ' + current">
          <span class="theme-icon">{{ icon }}</span>
          <span class="theme-label">{{ current }}</span>
        </button>
      `,
      data() {
        let savedTheme = 'system';
        try {
          savedTheme = localStorage.getItem('theme') || 'system';
        } catch {
          // Storage blocked by browser privacy settings
        }
        return {
          current: savedTheme,
        };
      },
      computed: {
        icon() {
          const icons = { light: '‚òÄÔ∏è', dark: 'üåô', system: 'üíª' };
          return icons[this.current] || 'üíª';
        },
      },
      methods: {
        cycle() {
          const modes = ['light', 'dark', 'system'];
          const idx = modes.indexOf(this.current);
          this.current = modes[(idx + 1) % modes.length];
          this.apply();
        },
        apply() {
          try {
            localStorage.setItem('theme', this.current);
          } catch {
            // Storage blocked by browser privacy settings
          }
          document.documentElement.setAttribute('data-theme', this.current);
        },
      },
      mounted() {
        this.apply();
      },
    });

    // ===== SessionSelector Component =====
    app.component('session-selector', {
      props: ['sessions', 'currentSession', 'modelValue'],
      emits: ['update:modelValue'],
      template: `
        <div class="session-selector">
          <label>Session:</label>
          <select
            :value="modelValue"
            @change="$emit('update:modelValue', $event.target.value)"
            class="session-select"
          >
            <option v-for="s in sessions" :key="s.session_id" :value="s.session_id">
              {{ s.session_id.slice(0, 8) }}{{ s.session_id === currentSession ? ' (current)' : '' }}
              - {{ s.entry_count }} entries
            </option>
          </select>
        </div>
      `
    });

    // ===== EventFilterDropdown Component =====
    app.component('event-filter-dropdown', {
      props: {
        modelValue: {
          type: Array,
          default: () => []
        },
        eventTypes: {
          type: Array,
          required: true
        }
      },
      data() {
        return {
          isOpen: false
        };
      },
      computed: {
        buttonLabel() {
          if (this.modelValue.length === 0) {
            return 'No Events';
          }
          if (this.modelValue.length === this.eventTypes.length) {
            return 'All Events';
          }
          if (this.modelValue.length === 1) {
            return this.modelValue[0];
          }
          return `${this.modelValue.length} Events`;
        }
      },
      methods: {
        toggle() {
          this.isOpen = !this.isOpen;
        },
        close() {
          this.isOpen = false;
        },
        isSelected(event) {
          return this.modelValue.includes(event);
        },
        toggleEvent(event) {
          const newValue = this.isSelected(event)
            ? this.modelValue.filter(e => e !== event)
            : [...this.modelValue, event];
          this.$emit('update:modelValue', newValue);
        },
        selectAll() {
          this.$emit('update:modelValue', [...this.eventTypes]);
        },
        clearAll() {
          this.$emit('update:modelValue', []);
        },
        handleClickOutside(event) {
          if (this.$el && !this.$el.contains(event.target)) {
            this.close();
          }
        }
      },
      mounted() {
        document.addEventListener('click', this.handleClickOutside);
      },
      beforeUnmount() {
        document.removeEventListener('click', this.handleClickOutside);
      },
      template: `
        <div class="event-dropdown">
          <button
            type="button"
            class="event-dropdown-trigger"
            @click.stop="toggle"
          >
            {{ buttonLabel }}
            <span class="dropdown-arrow">{{ isOpen ? '‚ñ≤' : '‚ñº' }}</span>
          </button>
          <div v-if="isOpen" class="event-dropdown-panel">
            <div class="event-dropdown-header">
              <button type="button" @click="selectAll">Select All</button>
              <button type="button" @click="clearAll">Clear</button>
            </div>
            <div class="event-dropdown-list">
              <label
                v-for="event in eventTypes"
                :key="event"
                class="event-checkbox"
              >
                <input
                  type="checkbox"
                  :checked="isSelected(event)"
                  @change="toggleEvent(event)"
                />
                <span class="event-badge" :class="'badge-' + event">
                  {{ event }}
                </span>
              </label>
            </div>
          </div>
        </div>
      `
    });

    // ===== FilterBar Component =====
    app.component('filter-bar', {
      props: {
        sessions: {
          type: Array,
          default: () => [],
        },
        currentSession: {
          type: String,
          default: null,
        },
        selectedSession: {
          type: String,
          default: null,
        },
        modelValue: {
          type: Object,
          default: () => ({
            search: '',
            eventTypes: [],
            sessionId: null,
          }),
        },
      },
      emits: ['update:modelValue', 'update:selectedSession'],
      template: `
        <div class="filter-bar">
          <div class="filter-row filter-row-main">
            <input
              type="text"
              class="search-input"
              placeholder="Search logs..."
              :value="modelValue.search"
              @input="onSearchInput"
            />

            <event-filter-dropdown
              :model-value="modelValue.eventTypes"
              :event-types="eventTypes"
              @update:model-value="emit({ eventTypes: $event })"
            />

            <button class="clear-filters-btn" @click="clearFilters" :disabled="!hasFilters">
              Clear Filters
            </button>
          </div>

          <div class="filter-row filter-row-top">
            <session-selector
              :sessions="sessions"
              :current-session="currentSession"
              :model-value="selectedSession"
              @update:model-value="$emit('update:selectedSession', $event)"
            />
          </div>
        </div>
      `,
      data() {
        return {
          searchTimeout: null,
          eventTypes: [
            'UserPromptSubmit',
            'PreToolUse',
            'PostToolUse',
            'PostToolUseFailure',
            'Notification',
            'SessionStart',
            'SessionEnd',
            'Stop',
            'SubagentStart',
            'SubagentStop',
            'PreCompact',
            'PermissionRequest',
            'Heartbeat',
          ],
        };
      },
      computed: {
        hasFilters() {
          return (
            this.modelValue.search ||
            this.modelValue.eventTypes.length > 0
          );
        },
      },
      methods: {
        emit(updates) {
          this.$emit('update:modelValue', {
            ...this.modelValue,
            ...updates,
          });
        },
        onSearchInput(e) {
          // Debounce search
          clearTimeout(this.searchTimeout);
          this.searchTimeout = setTimeout(() => {
            this.emit({ search: e.target.value });
          }, 300);
        },
        clearFilters() {
          this.emit({
            search: '',
            eventTypes: [],
          });
          this.$emit('update:selectedSession', 'all');
        },
      },
      beforeUnmount() {
        clearTimeout(this.searchTimeout);
      },
    });

    // ===== LogEntry Component =====
    app.component('log-entry', {
      props: {
        entry: {
          type: Object,
          required: true,
        },
      },
      template: `
        <div class="card log-entry" :class="{ expanded: isExpanded }">
          <div class="card-header" @click="toggle">
            <span class="timestamp">{{ formatTime(entry.timestamp) }}</span>
            <event-badge :event="entry.event"></event-badge>
            <span class="entry-summary">{{ getSummary(entry) }}</span>
            <span class="session-id" :title="entry.session_id">
              {{ truncateId(entry.session_id) }}
            </span>
            <span class="expand-icon">{{ isExpanded ? '‚ñº' : '‚ñ∂' }}</span>
          </div>

          <div v-if="isExpanded" class="card-content">
            <div class="json-header">
              <span>Data</span>
              <button class="copy-btn" @click.stop="copyJson">
                {{ copied ? '‚úì Copied' : 'üìã Copy' }}
              </button>
            </div>
            <pre class="json-content" v-html="highlightedJson"></pre>
          </div>
        </div>
      `,
      data() {
        return {
          isExpanded: false,
          copied: false,
        };
      },
      computed: {
        formattedJson() {
          try {
            return JSON.stringify(this.entry.data, null, 2);
          } catch {
            return String(this.entry.data);
          }
        },
        highlightedJson() {
          let json = JSON.stringify(this.entry.data, null, 2);
          json = this.cleanupPaths(json);
          return this.syntaxHighlight(json);
        },
      },
      methods: {
        cleanupPaths(json) {
          // Replace home directory paths with ~ for readability
          // Supports Windows (C:\Users\<name>), Linux (/home/<name>), macOS (/Users/<name>)
          // JSON.stringify escapes backslashes, so patterns account for \\\\
          json = json.replace(/C:\\\\Users\\\\[^\\\\]+/g, '~');
          json = json.replace(/\/home\/[^/]+/g, '~');
          json = json.replace(/\/Users\/[^/]+/g, '~');

          // Convert remaining escaped backslashes to forward slashes for readability
          json = json.replace(/\\\\/g, '/');

          return json;
        },
        syntaxHighlight(json) {
          if (typeof json !== 'string') {
            json = JSON.stringify(json, null, 2);
          }
          // Escape HTML entities
          json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

          // Apply syntax highlighting
          return json.replace(
            /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
            function (match) {
              let cls = 'json-number';
              if (/^"/.test(match)) {
                if (/:$/.test(match)) {
                  cls = 'json-key';
                } else {
                  cls = 'json-string';
                }
              } else if (/true|false/.test(match)) {
                cls = 'json-boolean';
              } else if (/null/.test(match)) {
                cls = 'json-null';
              }
              return '<span class="' + cls + '">' + match + '</span>';
            }
          );
        },
        toggle() {
          this.isExpanded = !this.isExpanded;
        },
        formatTime(iso) {
          try {
            const date = new Date(iso);
            return date.toLocaleTimeString('en-US', {
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false,
            });
          } catch {
            return iso;
          }
        },
        truncateId(id) {
          if (!id || id.length <= 12) return id;
          return id.substring(0, 8) + '...';
        },
        getSummary(entry) {
          const data = entry.data || {};
          const truncate = (str, len = 50) =>
            str && str.length > len ? str.substring(0, len) + '...' : str;

          switch (entry.event) {
            case 'UserPromptSubmit':
              return truncate(data.prompt || data.message || '');
            case 'PreToolUse':
              return data.tool_name || data.toolName || '';
            case 'PostToolUse':
              const toolName = data.tool_name || data.toolName || '';
              const success = data.error ? '‚úó' : '‚úì';
              return `${toolName} ${success}`;
            case 'PostToolUseFailure':
              const failedTool = data.tool_name || data.toolName || '';
              const errorMsg = truncate(data.error || '', 30);
              return `${failedTool} - ${errorMsg}`;
            case 'SessionStart':
            case 'SessionEnd':
              return `Session: ${truncate(entry.session_id || '', 20)}`;
            case 'SubagentStart':
            case 'SubagentStop':
              return data.subagent_type || data.type || '';
            case 'Notification':
              return truncate(data.message || data.notification || '');
            case 'PermissionRequest':
              return data.permission_type || data.permission || '';
            case 'PreCompact':
              return truncate(data.reason || 'Context compaction');
            case 'Stop':
              return truncate(data.reason || 'User interrupt');
            default:
              return '';
          }
        },
        async copyJson() {
          try {
            const fullEntry = JSON.stringify(this.entry, null, 2);
            await navigator.clipboard.writeText(fullEntry);
            this.copied = true;
            setTimeout(() => {
              this.copied = false;
            }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
          }
        },
      },
    });

    // ===== LogViewer Component =====
    app.component('log-viewer', {
      props: {
        entries: {
          type: Array,
          default: () => [],
        },
        sessions: {
          type: Array,
          default: () => [],
        },
        currentSession: {
          type: String,
          default: null,
        },
        selectedSession: {
          type: String,
          default: null,
        },
      },
      emits: ['update:selectedSession'],
      template: `
        <div class="log-viewer">
          <filter-bar
            v-model="filters"
            :sessions="sessions"
            :current-session="currentSession"
            :selected-session="selectedSession"
            @update:selected-session="$emit('update:selectedSession', $event)"
          ></filter-bar>

          <div class="log-viewer-controls">
            <label class="auto-scroll-toggle">
              <input type="checkbox" v-model="autoScroll" />
              Auto-scroll to new entries
            </label>
            <span class="entry-count">
              Showing {{ filteredEntries.length }} of {{ entries.length }} entries
            </span>
          </div>

          <div
            v-if="filteredEntries.length === 0"
            class="empty-state"
          >
            <h3>No entries found</h3>
            <p v-if="hasFilters">Try adjusting your filters</p>
            <p v-else>Waiting for log entries...</p>
          </div>

          <div
            v-else
            ref="logList"
            class="log-list"
          >
            <log-entry
              v-for="entry in filteredEntries"
              :key="entryKey(entry)"
              :entry="entry"
            ></log-entry>
          </div>
        </div>
      `,
      data() {
        return {
          filters: {
            search: '',
            eventTypes: [],
            sessionId: null,
          },
          autoScroll: true,
        };
      },
      computed: {
        uniqueSessions() {
          const sessions = new Set(this.entries.map(e => e.session_id));
          return Array.from(sessions).sort();
        },
        filteredEntries() {
          return this.entries.filter(entry => {
            // Search filter
            if (this.filters.search) {
              const searchLower = this.filters.search.toLowerCase();
              const matchesSearch =
                entry.event.toLowerCase().includes(searchLower) ||
                entry.session_id.toLowerCase().includes(searchLower) ||
                JSON.stringify(entry.data).toLowerCase().includes(searchLower);
              if (!matchesSearch) return false;
            }

            // Event type filter
            if (this.filters.eventTypes.length > 0) {
              if (!this.filters.eventTypes.includes(entry.event)) {
                return false;
              }
            } else {
              // Hide Heartbeat events by default (they clutter the log)
              if (entry.event === 'Heartbeat') {
                return false;
              }
            }

            // Session filter
            if (this.filters.sessionId) {
              if (entry.session_id !== this.filters.sessionId) {
                return false;
              }
            }

            return true;
          }).slice().reverse();
        },
        hasFilters() {
          return (
            this.filters.search ||
            this.filters.eventTypes.length > 0 ||
            this.filters.sessionId
          );
        },
      },
      methods: {
        entryKey(entry) {
          return `${entry.timestamp}-${entry.event}-${entry.session_id}`;
        },
        scrollToTop() {
          if (!this.autoScroll) return;
          this.$nextTick(() => {
            const list = this.$refs.logList;
            if (list) {
              list.scrollTop = 0;
            }
          });
        },
      },
      watch: {
        entries: {
          handler() {
            this.scrollToTop();
          },
          deep: false,
        },
      },
    });

    // ===== TabContainer Component =====
    app.component('tab-container', {
      props: {
        tabs: {
          type: Array,
          default: () => [
            { id: 'logs', label: 'Event Log' },
            // Future tabs:
            // { id: 'analytics', label: 'Analytics' },
            // { id: 'sessions', label: 'Sessions' },
          ],
        },
        activeTab: {
          type: String,
          default: 'logs',
        },
      },
      emits: ['update:activeTab'],
      template: `
        <div class="tab-container">
          <nav class="tabs">
            <button
              v-for="tab in tabs"
              :key="tab.id"
              class="tab"
              :class="{ active: activeTab === tab.id }"
              @click="selectTab(tab.id)"
            >
              {{ tab.label }}
            </button>
          </nav>

          <div class="tab-content">
            <slot :name="activeTab">
              <slot></slot>
            </slot>
          </div>
        </div>
      `,
      methods: {
        selectTab(id) {
          this.$emit('update:activeTab', id);
        },
      },
    });

    // ===== DashboardView Component =====
    app.component('dashboard-view', {
      props: {
        data: { type: Object, default: null },
        loading: { type: Boolean, default: false },
      },
      data() {
        return {
          showEndedSessions: false,
          selectedTimespan: 'today',
          collapsedGroups: {
            commands: true,
            hooks: true,
            skills: true,
            mcpServers: true,
          },
          timespanOptions: [
            { value: 'today', label: 'Today' },
            { value: 'yesterday', label: 'Yesterday' },
            { value: 'thisWeek', label: 'This Week' },
            { value: 'lastWeek', label: 'Last Week' },
          ],
        };
      },
      computed: {
        filteredSessions() {
          if (!this.data || !this.data.sessions) return [];
          return this.data.sessions.filter(session => {
            // Filter by ended status
            if (!this.showEndedSessions && session.status === 'ended') {
              return false;
            }
            // Filter by timespan
            if (!this.isInTimespan(session)) {
              return false;
            }
            return true;
          });
        },
      },
      methods: {
        toggleGroup(group) {
          this.collapsedGroups[group] = !this.collapsedGroups[group];
        },
        isInTimespan(session) {
          const lastActivity = session.last_heartbeat || session.first_entry;
          if (!lastActivity) return true;

          const activityDate = new Date(lastActivity);
          const now = new Date();
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          const yesterday = new Date(today);
          yesterday.setDate(yesterday.getDate() - 1);
          const thisWeekStart = new Date(today);
          thisWeekStart.setDate(thisWeekStart.getDate() - thisWeekStart.getDay());
          const lastWeekStart = new Date(thisWeekStart);
          lastWeekStart.setDate(lastWeekStart.getDate() - 7);
          const lastWeekEnd = new Date(thisWeekStart);

          switch (this.selectedTimespan) {
            case 'today':
              return activityDate >= today;
            case 'yesterday':
              return activityDate >= yesterday && activityDate < today;
            case 'thisWeek':
              return activityDate >= thisWeekStart;
            case 'lastWeek':
              return activityDate >= lastWeekStart && activityDate < thisWeekStart;
            default:
              return true;
          }
        },
        formatTime(iso) {
          try {
            const date = new Date(iso);
            return date.toLocaleTimeString('en-US', {
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false,
            });
          } catch {
            return iso;
          }
        },
        formatNumber(num) {
          if (num == null) return '0';
          if (num >= 1_000_000) {
            return (num / 1_000_000).toFixed(1) + 'M';
          }
          if (num >= 1_000) {
            return (num / 1_000).toFixed(1) + 'K';
          }
          return String(num);
        },
        formatModelName(model) {
          // claude-opus-4-5-20251101 -> Opus 4.5
          const match = model.match(/claude-(\w+)-(\d+)-(\d+)/);
          if (match) {
            const name = match[1].charAt(0).toUpperCase() + match[1].slice(1);
            return name + ' ' + match[2] + '.' + match[3];
          }
          return model;
        },
        truncateCommand(cmd) {
          if (!cmd) return '';
          // Show last part of command path
          const parts = cmd.split(/[/\\]/);
          return parts[parts.length - 1] || cmd;
        },
      },
      template: `
    <div class="dashboard">
      <div v-if="loading && !data" class="dashboard-loading">
        Loading dashboard...
      </div>

      <div v-else-if="data" class="dashboard-content">
        <!-- Sessions Section -->
        <section class="dashboard-section">
          <div class="section-header">
            <h2>Sessions</h2>
            <div class="section-controls">
              <select v-model="selectedTimespan" class="timespan-select">
                <option v-for="opt in timespanOptions" :key="opt.value" :value="opt.value">
                  {{ opt.label }}
                </option>
              </select>
              <label class="show-ended-toggle">
                <input type="checkbox" v-model="showEndedSessions" />
                Show ended
              </label>
            </div>
          </div>
          <div v-if="filteredSessions.length > 0" class="session-grid">
            <div
              v-for="session in filteredSessions"
              :key="session.session_id"
              class="session-card"
              :class="'status-' + session.status"
            >
              <div class="session-header">
                <span class="session-id">{{ session.session_id.slice(0, 8) }}...</span>
                <span class="status-badge" :class="session.status">
                  {{ session.status }}
                </span>
              </div>
              <div class="session-stats">
                <div class="stat">
                  <span class="stat-label">Messages</span>
                  <span class="stat-value">{{ session.message_count }}</span>
                </div>
                <div class="stat">
                  <span class="stat-label">Tools</span>
                  <span class="stat-value">{{ session.tool_call_count }}</span>
                </div>
                <div class="stat">
                  <span class="stat-label">Compacts</span>
                  <span class="stat-value">{{ session.compaction_count }}</span>
                </div>
              </div>
              <div v-if="session.last_heartbeat" class="session-time">
                Last: {{ formatTime(session.last_heartbeat) }}
              </div>
            </div>
          </div>
          <div v-else class="config-list">
            <div class="empty">No sessions found for selected timespan</div>
          </div>
        </section>

        <!-- Token Usage Section -->
        <section v-if="data.globalStats" class="dashboard-section">
          <h2>Token Usage</h2>
          <div class="stats-grid">
            <div
              v-for="(usage, model) in data.globalStats.modelUsage"
              :key="model"
              class="model-stats"
            >
              <h3>{{ formatModelName(model) }}</h3>
              <div class="token-stats">
                <div class="token-stat">
                  <span class="label">Input</span>
                  <span class="value">{{ formatNumber(usage.inputTokens) }}</span>
                </div>
                <div class="token-stat">
                  <span class="label">Output</span>
                  <span class="value">{{ formatNumber(usage.outputTokens) }}</span>
                </div>
                <div class="token-stat">
                  <span class="label">Cache Read</span>
                  <span class="value">{{ formatNumber(usage.cacheReadInputTokens) }}</span>
                </div>
                <div class="token-stat">
                  <span class="label">Cache Write</span>
                  <span class="value">{{ formatNumber(usage.cacheCreationInputTokens) }}</span>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Configuration Section -->
        <section class="dashboard-section">
          <h2>Configuration</h2>

          <!-- Commands -->
          <div class="config-group" :class="{ collapsed: collapsedGroups.commands }">
            <div class="config-group-header" @click="toggleGroup('commands')">
              <span class="collapse-icon">{{ collapsedGroups.commands ? '‚ñ∂' : '‚ñº' }}</span>
              <h3>Commands ({{ data.commands.length }})</h3>
            </div>
            <div v-show="!collapsedGroups.commands" class="config-group-content">
              <div class="config-list">
                <div v-for="cmd in data.commands" :key="cmd.name" class="config-item">
                  <span class="config-name">/{{ cmd.name }}</span>
                  <span class="config-desc">{{ cmd.description || 'No description' }}</span>
                </div>
                <div v-if="data.commands.length === 0" class="empty">No commands configured</div>
              </div>
            </div>
          </div>

          <!-- Hooks -->
          <div class="config-group" :class="{ collapsed: collapsedGroups.hooks }">
            <div class="config-group-header" @click="toggleGroup('hooks')">
              <span class="collapse-icon">{{ collapsedGroups.hooks ? '‚ñ∂' : '‚ñº' }}</span>
              <h3>Hooks ({{ data.hooks.length }})</h3>
            </div>
            <div v-show="!collapsedGroups.hooks" class="config-group-content">
              <div class="config-list">
                <div
                  v-for="(hook, index) in data.hooks"
                  :key="hook.eventName + index"
                  class="config-item"
                >
                  <span class="config-name">{{ hook.eventName }}</span>
                  <span class="config-desc">{{ truncateCommand(hook.command) }}</span>
                </div>
                <div v-if="data.hooks.length === 0" class="empty">No hooks configured</div>
              </div>
            </div>
          </div>

          <!-- Skills -->
          <div class="config-group" :class="{ collapsed: collapsedGroups.skills }">
            <div class="config-group-header" @click="toggleGroup('skills')">
              <span class="collapse-icon">{{ collapsedGroups.skills ? '‚ñ∂' : '‚ñº' }}</span>
              <h3>Skills ({{ data.skills.length }})</h3>
            </div>
            <div v-show="!collapsedGroups.skills" class="config-group-content">
              <div class="config-list">
                <div v-for="skill in data.skills" :key="skill.name" class="config-item">
                  <span class="config-name">{{ skill.name }}</span>
                  <span class="config-desc">{{ skill.description || 'No description' }}</span>
                </div>
                <div v-if="data.skills.length === 0" class="empty">No skills configured</div>
              </div>
            </div>
          </div>

          <!-- MCP Servers -->
          <div class="config-group" :class="{ collapsed: collapsedGroups.mcpServers }">
            <div class="config-group-header" @click="toggleGroup('mcpServers')">
              <span class="collapse-icon">{{ collapsedGroups.mcpServers ? '‚ñ∂' : '‚ñº' }}</span>
              <h3>MCP Servers ({{ data.mcpServers.length }})</h3>
            </div>
            <div v-show="!collapsedGroups.mcpServers" class="config-group-content">
              <div class="config-list">
                <div v-for="server in data.mcpServers" :key="server" class="config-item">
                  <span class="config-name">{{ server }}</span>
                </div>
                <div v-if="data.mcpServers.length === 0" class="empty">No MCP servers enabled</div>
              </div>
            </div>
          </div>
        </section>
      </div>

      <div v-else class="dashboard-empty">
        <h3>Dashboard unavailable</h3>
        <p>Unable to load dashboard data</p>
      </div>
    </div>
  `,
    });

    // ===== PlanTrackerView Component =====
    app.component('plan-tracker-view', {
      props: {
        plans: { type: Array, default: () => [] },
        loading: { type: Boolean, default: false },
      },
      data() {
        return {
          showCompleted: true,
          expandedPlans: new Set(),
          expandedFeatures: new Set(),
          groupByLayer: false,
        };
      },
      computed: {
        filteredPlans() {
          if (this.showCompleted) return this.plans;
          return this.plans.filter(p => p.status === 'active');
        },
        activePlanCount() {
          return this.plans.filter(p => p.status === 'active').length;
        },
        completedPlanCount() {
          return this.plans.filter(p => p.status === 'completed').length;
        },
      },
      methods: {
        togglePlan(name) {
          if (this.expandedPlans.has(name)) {
            this.expandedPlans.delete(name);
          } else {
            this.expandedPlans.add(name);
          }
          this.$forceUpdate();
        },
        toggleFeature(featureId) {
          if (this.expandedFeatures.has(featureId)) {
            this.expandedFeatures.delete(featureId);
          } else {
            this.expandedFeatures.add(featureId);
          }
          this.$forceUpdate();
        },
        isPlanExpanded(name) {
          return this.expandedPlans.has(name);
        },
        isFeatureExpanded(featureId) {
          return this.expandedFeatures.has(featureId);
        },
      },
      template: `
        <div class="plan-tracker">
          <div class="plan-controls">
            <label>
              <input type="checkbox" v-model="showCompleted" />
              Show completed plans
            </label>
            <label>
              <input type="checkbox" v-model="groupByLayer" />
              Group by layer
            </label>
            <span class="plan-count">
              {{ activePlanCount }} active, {{ completedPlanCount }} completed
            </span>
          </div>

          <div v-if="loading && plans.length === 0" class="plan-empty">
            <h3>Loading plans...</h3>
          </div>

          <div v-else-if="filteredPlans.length === 0" class="plan-empty">
            <h3>No plans found</h3>
            <p>Create a plan with /optimize-plan or check dev/active directory</p>
          </div>

          <div v-else class="plan-grid">
            <plan-card
              v-for="plan in filteredPlans"
              :key="plan.name"
              :plan="plan"
              :expanded="isPlanExpanded(plan.name)"
              :expanded-features="expandedFeatures"
              :group-by-layer="groupByLayer"
              @toggle="togglePlan(plan.name)"
              @toggle-feature="toggleFeature"
            ></plan-card>
          </div>
        </div>
      `,
    });

    // ===== PlanCard Component =====
    app.component('plan-card', {
      props: {
        plan: { type: Object, required: true },
        expanded: { type: Boolean, default: false },
        expandedFeatures: { type: Object, default: () => new Set() },
        groupByLayer: { type: Boolean, default: false },
      },
      emits: ['toggle', 'toggle-feature'],
      data() {
        return {
          details: null,
          loadingDetails: false,
        };
      },
      computed: {
        progressPercent() {
          if (this.plan.featureCount === 0) return 0;
          return Math.round((this.plan.completedCount / this.plan.featureCount) * 100);
        },
        progressClass() {
          if (this.plan.failedCount > 0) return 'has-failed';
          if (this.plan.inProgressCount > 0) return 'in-progress';
          return '';
        },
        groupedFeatures() {
          if (!this.details || !this.groupByLayer) return null;
          const groups = {};
          for (const feature of this.details.features) {
            const layer = feature.layer || 0;
            if (!groups[layer]) {
              groups[layer] = {
                name: this.details.layers?.[layer] || 'Layer ' + layer,
                features: [],
              };
            }
            groups[layer].features.push(feature);
          }
          return Object.values(groups).sort((a, b) =>
            (a.features[0]?.layer || 0) - (b.features[0]?.layer || 0)
          );
        },
      },
      watch: {
        expanded: {
          immediate: true,
          handler(isExpanded) {
            if (isExpanded && !this.details) {
              this.fetchDetails();
            }
          },
        },
      },
      methods: {
        async fetchDetails() {
          this.loadingDetails = true;
          try {
            const res = await fetch('/api/plans/' + this.plan.name);
            if (res.ok) {
              this.details = await res.json();
            }
          } catch (err) {
            console.error('Failed to fetch plan details:', err);
          } finally {
            this.loadingDetails = false;
          }
        },
        isFeatureExpanded(featureId) {
          return this.expandedFeatures.has(featureId);
        },
      },
      template: `
        <div class="plan-card" :class="'status-' + plan.status">
          <div class="plan-card-header" @click="$emit('toggle')">
            <div class="plan-title">
              <h3>{{ plan.project || plan.name }}</h3>
              <span class="plan-status-badge" :class="plan.status">
                {{ plan.status }}
              </span>
            </div>
            <p v-if="plan.description" class="plan-description">
              {{ plan.description }}
            </p>
            <div class="plan-progress">
              <div class="progress-bar">
                <div
                  class="progress-fill"
                  :class="progressClass"
                  :style="{ width: progressPercent + '%' }"
                ></div>
              </div>
              <div class="progress-text">
                {{ plan.completedCount }}/{{ plan.featureCount }} features
                ({{ progressPercent }}%)
                <span v-if="plan.inProgressCount > 0">
                  - {{ plan.inProgressCount }} in progress
                </span>
                <span v-if="plan.failedCount > 0">
                  - {{ plan.failedCount }} failed
                </span>
              </div>
            </div>
          </div>

          <div v-if="expanded" class="plan-card-content">
            <div v-if="loadingDetails" class="plan-empty">
              Loading features...
            </div>

            <template v-else-if="details">
              <!-- Grouped by layer -->
              <template v-if="groupByLayer && groupedFeatures">
                <div v-for="group in groupedFeatures" :key="group.name" class="layer-group">
                  <div class="layer-header">{{ group.name }}</div>
                  <ul class="feature-list">
                    <feature-item
                      v-for="feature in group.features"
                      :key="feature.id"
                      :feature="feature"
                      :expanded="isFeatureExpanded(feature.id)"
                      @toggle="$emit('toggle-feature', feature.id)"
                    ></feature-item>
                  </ul>
                </div>
              </template>

              <!-- Flat list -->
              <ul v-else class="feature-list">
                <feature-item
                  v-for="feature in details.features"
                  :key="feature.id"
                  :feature="feature"
                  :expanded="isFeatureExpanded(feature.id)"
                  @toggle="$emit('toggle-feature', feature.id)"
                ></feature-item>
              </ul>
            </template>
          </div>
        </div>
      `,
    });

    // ===== FeatureItem Component =====
    app.component('feature-item', {
      props: {
        feature: { type: Object, required: true },
        expanded: { type: Boolean, default: false },
      },
      emits: ['toggle'],
      template: `
        <li class="feature-item" @click="$emit('toggle')">
          <span class="feature-status-dot" :class="feature.status"></span>
          <div class="feature-content">
            <div class="feature-title">{{ feature.title }}</div>
            <div class="feature-meta">
              <span class="feature-layer">L{{ feature.layer }}</span>
              <span>{{ feature.id }}</span>
            </div>
            <div v-if="expanded" class="feature-details">
              <p v-if="feature.description">{{ feature.description }}</p>

              <h4 v-if="feature.acceptanceCriteria?.length">Acceptance Criteria</h4>
              <ul v-if="feature.acceptanceCriteria?.length">
                <li v-for="(criterion, i) in feature.acceptanceCriteria" :key="i">
                  {{ criterion }}
                </li>
              </ul>

              <h4 v-if="feature.files?.length">Files</h4>
              <ul v-if="feature.files?.length">
                <li v-for="(file, i) in feature.files" :key="i">{{ file }}</li>
              </ul>

              <h4 v-if="feature.dependencies?.length">Dependencies</h4>
              <ul v-if="feature.dependencies?.length">
                <li v-for="(dep, i) in feature.dependencies" :key="i">{{ dep }}</li>
              </ul>
            </div>
          </div>
        </li>
      `,
    });

    // Mount the app
    app.mount('#app');
  </script>
</body>
</html>
